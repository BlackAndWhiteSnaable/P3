\chapter{Pathfinding}\label{ch:path}
Pathfinding is generally the process of finding a path from a given starting point ('A')
to a given destination ('B'),
on a given map.
Handling the map is explained in chapter \ref{ch:map}.

There are different approaches to find the best path,
and different ideas what the best path is.

In the case of rescue, where time is very crucial to success,
the quickest path has to be considered best. \cite{Zipes2506}

In other applications 'best' could also mean shortest distance, least expensive (toll roads),
most convenient or any number of other qualifiers.

Since our robot has approximately equal movement speed in all used directions,
the shortest time path can be approximated as the shortest distance path.

We chose to start implementing Dijkstra's shortest path algorithm,
since it is fairly simple to understand and can be used as a baseline for better,
more complex algorithms, like A*.

This chapter will explain the basics of different path finding approaches,
going more into detail on the ones we chose to implement for testing.

\section{Graphs}
The first step in most algorithms is to reduce the map to the necessary minimum.
After this reduction, the map only consists of \emph{nodes} and \emph{edges},
organized in a \emph{graph}.

An edge connects two nodes together and has a \emph{distance}.
In this integer is stored how much it costs to traverse along that edge,
measured in the metric that should get optimized (in our case distance and approximate time).

A node has a \emph{name}, a \emph{cost to reach} and a reference to another node \emph{parent}.
The name is used as an identifier,
cost to reach sums the travelling costs to get here on the currently shortest path from the start.
Parent refers to what node is previous in that path.

Two nodes also have a special characteristic,
the previously named starting position and the finish position.


\begin{figure}[h!tp]
    \centering
    \subfloat[grid graph]{
        \includegraphics[width=0.24\textwidth]{figures/path/graph_grid}
        \label{sub:grid}
    }
    \subfloat[circular graph]{
        \includegraphics[width=0.24\textwidth]{figures/path/graph_circular}
    }
    \subfloat[tree graph]{
    	\includegraphics[width=0.24\textwidth]{figures/path/graph_tree}
    }
  	\subfloat[unstructured graph]{
  		\includegraphics[width=0.24\textwidth]{figures/path/graph_unstructured}
	}
  	\caption{different representations of the same graph}
  	\label{fig:graphs}
\end{figure}

Such a graph can be represented in any way,
as long as none of the described characteristics change.
Figure \ref{fig:graphs} shows four equivalent representations of the same graph.
We chose to omit any numbers for simplicity.

Since our prototype is running on a grid-like map,
the graph shown in figure \ref{sub:grid} is our preferred representation,
since it is the easiest to relate to the real world for a human.
For the algorithm however, it doesn't matter.
\\\\
\section{Brute-Force}\label{sec:brute}
Brute-force is generally an algorithm,
that only relies on computational power,
instead of clever design.
For path-finding that would mean looking at all possible paths,
and evaluating which one is the shortest.
Brute-force algorithms can be implemented as a depth first search (DFS), or breadth first search(BFS).

\section{Flood Fill}\label{sec:fill}
Flood fill is looking at all neighbour nodes from the start,
and looking at all their neighbours.
This process then gets repeated until the finish node is reached.
Because the algorithm expands first in breadth,
this is a BFS-algorithm.

The name comes from visualising the algorithm,
which looks fairly similar to a liquid being spilled on a map.
%flood fill can be seen in figure something later
\cite{Jaimini2017}

\section{Dijkstra}\label{sec:dijkstra}
Dijkstra's algorithm is a small improvement on the flood-fill algorithm explained earlier.
It takes into account the distances between two nodes,
when deciding which node to look at next.
Thus prioritising the easier to reach nodes, when going to the next iteration.

This is done by storing all nodes in a priority queue,
where they are sorted by their cost to reach, lowest first.

The cost to reach gets calculated iteratively,
by adding the cost to reach of the current node together with the travel cost to its neighbour.
If that value is smaller than the cost to reach currently stored in that neighbour,
the old value gets overwritten.
This process is shown stepwise in figures \ref{sub:dijk1} through \ref{sub:dijk5}.
Observe how the value for the finish node changes in almost every step,
until the finish node is the current node.

Every time the algorithm needs a new node to evaluate its neighbours,
it takes the first element from that list.

\begin{figure}[h!]
	\begin{center}
		\foreach \dijk in {1,2,3,4,5}
		{
			\subfloat[\dijk. Step]{
				\includegraphics[width=0.17775\textwidth]{figures/path/dijk_\dijk}
				\label{sub:dijk\dijk}
			}
		}
		\caption{Dijkstra's algorithm on a simple map}
		\label{fig:dijksteps}
	\end{center}
\end{figure}
%
\begin{table}[h!]
\caption{Colour guide for figure \ref{fig:dijksteps}}
\centering
\begin{tabular}{|l|p{2.5cm}|p{2.5cm}|}
	\hline%-------------------------------------------------------
	\multirow{2}{*}{Colour}	& \multicolumn{2}{c|}{Function}		\\
		 	& Nodes					&Edges						\\
	\hline%-------------------------------------------------------
	Red		&						&Used in current evaluation	\\
	\hline%-------------------------------------------------------
	Orange 	& Current Node			&							\\
	\hline%-------------------------------------------------------
	Green	& Evaluated Neighbour	&							\\
	\hline%-------------------------------------------------------
	White	& Not active yet		&							\\
	\hline%-------------------------------------------------------
	Black  &Shortest Path already found&Not used in current step\\
	\hline%-------------------------------------------------------
\end{tabular}
\end{table}

This approach is a huge benefit for maps,
where distances between nodes vary widely.
In our case distances are one of two possibilities, either $1$ or $ \sqrt{2} $.
Thus making this effectively one implementation of a flood-fill search,
with the benefit, that only one addition needs to be done to implement A*,
which gets explained in section \ref{sec:astar}.

\section{A*}\label{sec:astar}
A* uses Dijkstra's algorithm as a baseline,
but adds a heuristic to each node.


\section{Pathfinding on a grid}
Pathfinding on a grid is slightly different to pathfinding on a regular map,
because all nodes tend to have the same amount of neighbours,
and all edges have the same or similar costs.
Figure \ref{fig:graph_cost} shows the similarities between several connections on a grid-based graph.
because of this, the Dijkstra algorithm is losing its major advantage over a simple flood fill.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.24\textwidth]{figures/path/graph_values}
	\caption{3x3 grid with edge costs}
	\label{fig:graph_cost}
\end{figure}


\section{Our implementation}
\todo[inline]{does this belong into sec:map-handle?}
For our grid we chose to allow vertical, horizontal and diagonal movement,
giving us 8 possible directions to move in from every node.
We decided to store those eight directions in one single byte,
with the least significant nibble (LSN) corresponding to the four main directions (N,E,S,W),
and the MSN corresponding to NE, SE, SW and NW.

\begin{center}
	\begin{tabular}{|*{8}{m{0.6cm}|}|l|}
		\hline
		N & E& S& W& NE& SE& SW& NW& byte\\
		\hline
		0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0x01\\
		0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0x02\\
		0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0x03\\
		0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0x0E\\
		\hline
		0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0x10\\
		0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0x20\\
		0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0x42\\
		1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0xFF\\
		\hline
	\end{tabular}
\end{center}

Just some random cites, to see how it works.
\cite{Madsen2010}, \cite{Oetiker2010} and \cite{Mittelbach2005}.
