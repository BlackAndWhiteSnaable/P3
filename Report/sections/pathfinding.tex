\chapter{Pathfinding}\label{ch:path}
Pathfinding is generally the process of finding a path from a given starting point ('A')
to a given destination ('B'),
on a given map.

There are different approaches to find the best path,
and different ideas what the best path is.

In the case of rescue, where time is very crucial to success,
the quickest path has to be considered best. \cite{Zipes2506}

In other applications 'best' could also mean shortest distance, least expensive (toll roads),
most convenient or any number of other qualifiers.

Since our robot has approximately equal movement speed in all used directions,
the shortest distance path can be approximated as the shortest time path.

We chose to start implementing Dijkstra's shortest path algorithm,
since it is fairly simple to understand and can be used as a baseline for better,
more complicated algorithms, like A*.

\section{Graphs}
The first step in most algorithms is to reduce the map to the necessary minimum.
After this reduction, the map only consists of \emph{nodes} and \emph{edges},
organized in a graph.
An edge connects two nodes together and has a \emph{distance}.
In this integer is stored how much it costs to traverse along that edge,
measured in the metric that should get optimized (in our case distance and time).

A node has a \emph{name}, a \emph{cost to reach} and a reference to another node \emph{parent}.
The name is used as an identifier,
cost to reach sums the travelling costs to get here on the currently shortest path from the start
and parent refers to what node is previous in that path.

Two nodes also have a special characteristic,
the previously named starting position and the finish position.


\begin{figure}[htp]
    \centering
    \subfloat[grid graph]{
        \includegraphics[width=0.24\textwidth]{figures/path/graph_grid}
        \label{sub:grid}
    }
    \subfloat[circular graph]{
        \includegraphics[width=0.24\textwidth]{figures/path/graph_circular}
    }
    \subfloat[tree graph]{
    	\includegraphics[width=0.24\textwidth]{figures/path/graph_tree}
    }
  	\subfloat[unstructured graph]{
  		\includegraphics[width=0.24\textwidth]{figures/path/graph_unstructured}
	}
  	\caption{different representations of the same graph}
  	\label{fig:graphs}
\end{figure}

Such a graph can be represented in any way,
as long as none of the described characteristics change.
Figure \ref{fig:graphs} shows four different representations of the same graph (with omitted number values).

Since our prototype is running on a grid-like map,
the graph shown in figure \ref{sub:grid} is our preferred representation.
For the algorithm however, it doesn't matter.
\\\\
\section{Brute-Force}\label{sec:brute}
Brute-force is generally an algorithm,
that only relies on computational power,
instead of clever design.
For path-finding that would mean looking at all possible paths,
and evaluating which one is the shortest.
Brute-force algorithms can be implemented to search depth first (DFS), or breadth first (BFS).

\section{Flood Fill}\label{sec:fill}
Flood fill is looking at all neighbour nodes from the start,
and looking at all their neighbours.
This process then gets repeated until the finish node is reached.
The name comes from visualising the algorithm,
which looks fairly similar to a liquid being spilled on a map.
%flood fill can be seen in figure something later
\cite{Jaimini2017}


\section{Dijkstra}\label{sec:dijkstra}
Dijkstra's algorithm is a small improvement on the flood-fill algorithm explained earlier.
It takes into account the distances between two nodes,
when deciding which node to look at next.
Thus prioritising the easier to reach nodes, when going to the next iteration.

This is done by storing all nodes in a priority queue,
where they are sorted by their distance, lowest first.
Every time the algorithm needs a new node to evaluate its neighbours,
it takes the first element from that list.

This approach is a huge benefit for maps,
where distances between nodes vary widely.
In our case distances are one of two possibilities, either $1$ or $ \sqrt{2} $.
Thus making this effectively one implementation of a flood-fill search,
with the benefit, that only one addition needs to be done to implement A*,
which gets explained in section \ref{sec:astar}.
\\\\
Those values then get added to and stored  inside the neighbours' distance with A as the parent.
Now the starting node gets marked as done
and the node with the lowest distance gets selected
as the starting point for the next round of calculations

\section{A*}\label{sec:astar}
nothing here yet

\section{Pathfinding on a grid}
Pathfinding on a grid is slightly different to pathfinding on a regular map,
because all nodes tend to have the same amount of neighbours,
and all edges have the same or similar costs.
Figure \ref{fig:graph_cost} shows the similarities between several connections on a grid-based graph.
because of this, the Dijkstra algorithm is losing its major advantage over a simple flood fill.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.24\textwidth]{figures/path/graph_values}
	\caption{3x3 grid with edge costs}
	\label{fig:graph_cost}
\end{figure}
%\missingfigure{closeup of a grid map, with values}


\section{Our implementation}
\todo[inline]{does this belong into sec:map-handle?}
For our grid we chose to allow vertical, horizontal and diagonal movement,
giving us 8 possible directions to move in from every node.
We decided to store those eight directions in one single byte,
with the least significant nibble (LSN) corresponding to the four main directions (N,E,S,W),
and the MSN corresponding to NE, SE, SW and NW.

\begin{center}
	\begin{tabular}{|*{8}{m{0.6cm}|}|l|}
		\hline
		N & E& S& W& NE& SE& SW& NW& byte\\
		\hline
		0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0x01\\
		0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0x02\\
		0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0x03\\
		0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0x0E\\
		\hline
		0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0x10\\
		0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0x20\\
		0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0x42\\
		1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0xFF\\
		\hline
	\end{tabular}
\end{center}

Just some random cites, to see how it works.
\cite{Madsen2010}, \cite{Oetiker2010} and \cite{Mittelbach2005}.
