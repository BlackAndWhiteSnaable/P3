\chapter{Perspective}
\section{Efficiency}
The code written for this project was not designed to be efficient,
but to be understandable to the reader and the authors,
because efficiency was outside the scope of the project.

In a real world scenario,
efficiency both in time and power consumption is crucial to the effectiveness of a rescue robot.

Because of this we want to at least formulate our thoughts on the topic.
\subsection{Pathfinding}
Pathfinding is probably the most resource-heavy calculation in our system,
and will likely be executed several times while running.

Most pathfinding algorithms need several variables to be stored and accessed multiple times,
for each node.
We decided to store them in structs for our implementation.

\lstinputlisting
[firstline=24,				%starts reading the file from this line
firstnumber=24,
lastline=31,
label=lst:structs,	%label
caption={Declaring a Struct  in {\tt defs.h}}
]{code/defs.h}
%
An example of a struct declaration can be seen in Listing \ref{lst:structs}.
A struct stores all declared variables as an individual variable,
with pointers to them.
This makes it easy to access them for the programmer,
but creates a notable overhead when compiling.

Depending on the word size of the used processor,
it could be possible to store all information necessary for a node in one variable.
This would necessitate inventing a custom encoding,
but would possibly improve time consumption on runtime.

One idea for this would be to reserve sections of the variables bits for specific information,
our thoughts on how that might look can be seen in Table \ref{tab:encode}.

\begin{table}[h]
\caption{Example of a possible custom Encoding for Nodes}
\begin{tabularx}{\textwidth}{|*{32}{X|}}
	\hline
	\multicolumn{8}{|>{\hsize=\dimexpr2\hsize+2\tabcolsep+\arrayrulewidth\relax}X|}{position}&
	\multicolumn{8}{>{\hsize=\dimexpr2\hsize+2\tabcolsep+\arrayrulewidth\relax}X|}{walls}&
	\multicolumn{8}{>{\hsize=\dimexpr2\hsize+2\tabcolsep+\arrayrulewidth\relax}X|}{parent}&
	\multicolumn{8}{>{\hsize=\dimexpr8\hsize+10\tabcolsep+\arrayrulewidth\relax}X|}{movecost}\\
	\hline
	1&1&0&1&1&0&0&1&0&1&0&1&1&0&0&0&0&1&1&1&0&0&1&0&1&0&1&1&1&1&1&1\\
	\hline
\end{tabularx}
\label{tab:encode}
\end{table}
%
Single values could be retrieved through simple bitwise operations,
implemented either in hardware or in software.
To retrieve the position for example,
the whole value could be shifted to the right 24 times.

To select the parent position,
one could take the value {\tt AND} {\tt 0xFF00} and
afterwards shift to the right 8 times.

Our current approach takes use of pointers a lot,
often iterating through several substructs.
Listing \ref{lst:pointer_access} shows code with multiple pointer accesses per line,
varying from 2 to 4 for a single line.
Code similar to this listing gets executed up to 8 times per \emph{node},
for every \emph{node} with a lower \emph{cost to reach} than the finish \emph{node},
to check for every direction whether moving there would be shorter.

\lstinputlisting
[firstline=84,				%starts reading the file from this line
firstnumber=84,
lastline=88,
label=lst:pointer_access,	%label
caption={Accessing several Fields through multiple Pointers in {\tt path.c}}
]{code/path.c}
%
When implementing Dijkstra's algorithm or A*,
there is no need to look at an already checked \emph{node}.
It could therefore be an option to remove all pointers to a node,
when pushing it to the checked stack.

In our current implementation,
those pointers can only be set to {\tt NULL} after finding them through another pointer lookup.
We are already doing this in line 87 in Listing \ref{lst:pointer_access},
when removing the reference to the parent as a neighbour,
to remove redundant information and ease the lookup procedure.

The whole part of linking the \emph{nodes} to their neighbours,
as explained in \ref{lst:linkingByte},
uses the aforementioned {\tt walls} byte,
to compute in what directions to link.

\lstinputlisting
[firstline=7,				%starts reading the file from this line
firstnumber=7,
lastline=20,
label=lst:linkingByte,	%label
caption={Accessing several Fields through multiple Pointers in {\tt path.c}}
]{code/path.c}
%
Because our \emph{nodes} are organized in a 2D-array,
this includes array and pointer lookups,
simple arithmetic and
bitwise comparison
to find all \emph{nodes} and link them.

\section{Design flaws}
edges are defined twice, from both nodes
\todo[inline,color=codegreen]{finish this sector}