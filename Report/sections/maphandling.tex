% Introduction

% ??? NEED block diagram of go()! check map? scan: yes/no? save map, move etc. (use that online code to block diagram tool)
% ??? Descripe framework in a section (see gdocs for input to block diagram) (or present at exam)
% ??? Mention we chose to focus on making our own code with the least use of finished libraries as possible, no error handling 
% ??? Mention the report will explain important aspects of out work and theoretical parts, 
%     while the finished product is a prototype and the code in the appendix
% 

% Problem / introduction?:
% - Problem and analysis:
% 	- https://en.wikipedia.org/wiki/Rescue_robot
%	- https://www.robocupgermanopen.de/sites/default/files/rescue_maze_2017.pdf
% - System diagram (what we want to build):
% Daniel has already made a nice diagram of this
% Current position should be known after each move.

% - Prototype / mechanical design / robot design (show what we wanted to to build)
% - maybe here with motor/wheels under it? chasis?
% - maybe under "problem and analysis"


% Programming Structure and Design: (try to fulfill some Akbar goals here, see those gdocs notes)
%- Robot Instruction Execution Order
%- Framework
%- Data Structure



% Robot control: (maybe after pathfinding?)
% Theory:
% - functionality
% - step/control sequence
% Implementation: (programming)
% - programming/framework etc.

% Map handling:
% Theory (how we did and thoughts):
% - Introduction (what is map handling about, what have we covered here, problems we want to solve)
% - Analysis of map input
% - Converting analog map to digital map (intro)
% - 
% Implementation:
% - Read, compare, update 

% Prototype:
% maybe something about the prototype here??
% or in conclusion at least
% read google docs



\chapter{Map Handling}
\label{ch:map_handling} % chapter label
The rescue robot should be able follow a given path from start to finish, based on a predefined map given as input.
A map provides useful information about whether areas of the map are accessible or not. Map data can be loaded by the robot prior to its physical presence at a location. Once the robot is at the starting point, it has to rely on its sensors for updated information about the surroundings. 

The map itself is a crucial part, that converted into to a graph is used by the path-finding as explained in Chapter \ref{ch:path}. Hence a structured way of storing the required map data for different maps was designed. The primary goal was make it readable by the microcontroller, but also still allow easy user input.

%Existing pathfinding algorithms such as Dijkstra and A* was studied, 
%in order to understand what input data such algorithms typically would require. 
%The pathfinding algorihtm implemented in this project is further described in chapter \ref{ch:path}.

\newpage
\section{Map Requirements}
\label{sec:map_requirements}
Maps can be found in a lot of different styles,
varying in how they represent specific informations.
Those styles often depend on the purpose of the map.
Figure \ref{sub:orient} shows a map for casual orientation purposes,
while \ref{sub:evac} shows a standardized evacuation plan.

\begin{figure}[h!tp]
    \centering
    \subfloat[Section of AAU Esbjerg]{%
        \includegraphics[width=0.4\textwidth]{figures/map/floorplan_aau.png}%
        \label{sub:orient}
        }%
    \hspace{0.1\textwidth}
    \subfloat[School layout example]{%
        \includegraphics[width=0.4\textwidth]{figures/map/floorplan_school.png}%
        \label{sub:evac}
        }%
    \caption{Examples of different maps}
    \label{fig:floor_plans}
\end{figure}
% https://www.edrawsoft.com/school-layout-example.php

Maps are often very visual, providing a lot of detailed information to the reader.
The way the information is represented differently,
makes it very hard to be interpreted automatically.
A map must provide necessary information,
in a way that can be interpreted by the micro controller.
For this project we decided that a simplified map, would be sufficient.

Table \ref{table:map_data} shows the data the map should include,
as well as some areas that have been delimited from.

\begin{table}[h!]
	\centering
	\caption{Map data}
	\begin{tabular}{|p{0.4\textwidth}||p{0.4\textwidth}|}
		\hline
		Data to be included & Data to delimit from \\ 
		\hline
		Map dimensions 		& \parbox[t]{0.4\textwidth}{Differences in height\\(levels, stairs etc.)}\\
		\hline
		Start position 		& Door openings \\
		\hline
		Finish position 	& \parbox[t]{0.4\textwidth}{Ground surface\\(slipping, traction)} \\
		\hline
		Walls 				& Objects\\
		\hline
	\end{tabular}
	\label{table:map_data}
\end{table}

\section{Map Coordinates}
\label{sec:map_coordinates} % section label
During the theoretical development we often used hand-drawn 2D maps with grids as depicted in Figure \ref{sub:2d_map}. The map can have a certain size and allows for an object to have a location on the grid. A specific part of the map can easily be referred to by its unique coordinate in the x and y dimensions. 

For converting and storing analog maps into a usable digital representation with the same properties, we chose to use 2D arrays as data structure. A 2D array can be thought of as a matrix, where a grid of numbers can be arranged in rows and columns. 2D arrays are very similar to matrices, and differs in how elements are indexed.

The result of the different indexing methods can be seen by comparing Figure \ref{sub:2d_map} to \ref{sub:2d_array}. Given the same index values, the cell referred to would be different, as seen in  Figure \ref{sub:2d_map} and \ref{sub:2d_array}.


\begin{figure}[htp]
    \centering
    \subfloat[2D grid map]{%
        \includegraphics[width=0.45\textwidth]{figures/map/2d-map.png}%
        \label{sub:2d_map}
        }%  
    \hspace{0.05\textwidth}  
    \subfloat[2D array]{%
        \includegraphics[width=0.45\textwidth]{figures/map/2d-array.png}%
        \label{sub:2d_array}
        }%
    \caption{Difference in indexing for (3,4) in a 2D grid map and a 2D array}
    \label{fig:floor_plans}
\end{figure}
%https://i.stack.imgur.com/tFdLk.gif

Each cell in the map represents a map segment with its own coordinates. To allow for a more logical access to segments of the map in the actual programming, we chose to start map coordinates at zero. Rows and columns could be switched when needed. This could be either be done in the syntax, by switching i and j, or by switching the x and y axes when storing the map in the first place.
\\

\begin{lstlisting}[caption={Example of map segment before rows and columns are switched}]
Array: map[4][3], would give map coordinate (3,4)
\end{lstlisting}

\begin{lstlisting}[caption={Example of map segment after switching rows and columns}]
Array: map[3][4], would give map coordinate (3,4)
\end{lstlisting}

This lead to the final implementation in our program using 2D arrays, 
where the value of any given map segment easily could be accessed. 
\\
\begin{lstlisting}[caption={Example of implementation in the final code}]
Array: robot->map->segments[3][4], would return the value for map coordinate (3,4)
\end{lstlisting}
Examples of this can be seen implemented in the final code in appendix XX (some specific place?). 
\todo{fix referring to code in appendix, and code language should not be set to Python.} 
The same approach was used for handling node maps, which is further explained in Chapter \ref{ch:path}.

\newpage

\section{Map Design}
\label{sec:map_design} % section label
The grid-based map is made up of simple plain-text ASCII characters.
This makes it fairly simple and easy-to-understand, and maps can easily be created or changed by a user. 

An example of a map with 5x5 nodes can be seen in Figure \ref{sub:map_ascii}, where \# being walls, A being the start, B being the finish, o being nodes, and the white spaces being open spaces. The same map can be seen using UTF8 encoding in Figure \ref{sub:map_utf8}. UTF8 has a more characters to choose from, which makes it easier to read for humans while the plain-text version is easier to read for computers.

Nodes represent positions on the map where the robot can move between. The idea is to allow movement in eight directions, four straight and four diagonal, unless a direction is blocked by a wall. Nodes are explained further in Chapter \ref{ch:path}.

\begin{figure}[htp]
    \centering
    \subfloat[ASCII]{%
        \includegraphics[width=0.2\textwidth]{figures/map/5x5map_ascii-2.png}%
        \label{sub:map_ascii}

    }
    \hspace{0.2\textwidth}
    \subfloat[UTF8]{%
        \includegraphics[width=0.2\textwidth]{figures/map/5x5map_utf8-2.png}%
        \label{sub:map_utf8}
    }
    \caption{Example of a map with 5x5 nodes, having 11 characters per line and 11 lines.}
    \label{fig:5x5map}
\end{figure}

We found that making the map using UTF8 would require a bit more work, since text editors often add characters to the beginning of the file. 
This is known as the byte-order-mark (BOM) which indicates the file uses UTF8 encoding. 
It also uses variable bit-length for characters, between 1-4 bytes [https://en.wikipedia.org/wiki/UTF-8].
\todo{not wikipedia PLEASE!!} 
This makes reading and storing the map to a file more complicated, which is why we chose to use plain text ASCII.

\newpage
\section{Reading Map from a File}
\label{sec:map_read} % section label %
The function {\tt map\_load} loads map data from a file and saves it in the {\tt map} struct.
Start and finish positions are read from file as well and saved in {\tt robot} struct.
\todo{Write about structs in the beginning of the report}

Functions were made for reading a map, as well as writing an updated map to a text-file. 
The full code for the functions {\tt map\_load} and {\tt map\_save} can be seen in Appendix X.\todo{fix these references}
\todo[inline]{listing showing parts of these functions}
This was useful for developing and testing the subsystem on a computer. 
Implementing reading and writing to a file on the microprocessor, would require it to have a file system.
We chose not to implement this functionality, due to the restricted time frame of this project.
As an alternative, maps can be stored directly in the programming code although it is not user-friendly.
\todo{as a bad alternative?}

\todo[inline]{something in between, maybe some code?}
In the C programming language the size of an array must be declared at compile time. 
The array for the map has to be large enough to hold all the map data.
Unfortunately the map size and data remains unknown until a map is loaded, which happens at runtime.

The easiest option would be to use a fixed array size, large enough to store maps up to a predefined size. 
Instead we saw this as an opportunity to get some experience by working with dynamic memory allocation and pointers for this application.

The required size of the array can be calculated by counting the lines and characters of the map,
which is equivalent to the rows and columns needed for the array.
A map with 5x5 nodes will have 11 characters in each line and a total of 11 lines,
as illustrated in Figure \ref{fig:5x5map}.
To store the map, an 11x11 2D array is required.
Now that the required array size is known, it can be allocated in the memory.\\
\todo[inline]{insert code}
- Example of allocating 2d array

- putting data in 2d array ???\\

ORDER:\\
map load\\
hex values\\
node map load\\
scan\\
map save

\section{Scan Surroundings and Compare to Map}
\label{sec:map_check} % section label
\todo{rescuing situation}
There might be situations where parts of the map, or even the entire map would be incorrect.
External factors such as an explosion in a building would also change the surroundings dramatically.
 
After each move of the robot, distance sensors scans the surrounding environment in all possible move-directions.
Feedback from each sensor is compared to the corresponding map segments. 
If changes to the surroundings are detected, the map gets updated and saved to the text-file.
Every time the map changes, the path finding function is called\todo{insert function name}, to calculate the most efficient path from the robots current location to the finish. \todo{could be used to explain what the robot does, if not just leave it here.}



\section{Map Save}
\label{sec:map_save} % section label

\section{Walls / Neighbours hex}
\label{sec:map_hex} % section label
Maybe this should be part of map check

\section{Node Map}
\label{sec:map_node} % section label



